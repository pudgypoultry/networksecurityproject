[gd_scene load_steps=8 format=3 uid="uid://dlfbk3evu5pcy"]

[ext_resource type="PackedScene" uid="uid://dfctydsctrrvs" path="res://Scenes/menu_button.tscn" id="1_06n3i"]
[ext_resource type="FontFile" uid="uid://dta5ub6hkqfo8" path="res://Fonts/mmrock9/MMRock9.ttf" id="1_ybke6"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_d8ur5"]
content_margin_left = 20.0
content_margin_top = 20.0

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_bdfw8"]
content_margin_left = 20.0
content_margin_top = 20.0

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_pr0yy"]
content_margin_left = 20.0
content_margin_top = 20.0

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_7b7cj"]
content_margin_left = 20.0
content_margin_top = 20.0

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_nv0k5"]
content_margin_left = 20.0
content_margin_top = 15.0

[node name="ExplanationMenu" type="VBoxContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="TabContainer" type="TabContainer" parent="."]
layout_mode = 2
size_flags_vertical = 3
current_tab = 0

[node name="What is a float?" type="Label" parent="TabContainer"]
custom_minimum_size = Vector2(600, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("1_ybke6")
theme_override_styles/normal = SubResource("StyleBoxEmpty_d8ur5")
text = "
    A \"float\" is a data type used to represent non-integer numbers. When we program with them, they feel relatively intuitive to work with because we're thinking of them just as we normally would in any math class.

However, remember that computers must store all information in terms of bits. Because of this, there can be no infinity, and therefore we cannot have an infinitely small or large number in a in the same way we would be able to when working with algebra or calculus.

So then how are we using floats while we program? The IEEE, (The Institute of Electrical and Electronics Engineers), have a standard means of  closely approximating tiny and huge numbers using bits by assigning meaning to specific segments of bits. These meanings we've assigned to the first bit, the next 8 bits, and the remaining 23 bits effectively recreate the notion of scientific notation. 

As someone who uses base 10 on a daily basis, the most difficult part of learning how to convert floats to bits and vice versa will be converting that knowledge into base 2/binary in terms of scientific notation."
autowrap_mode = 2
metadata/_tab_index = 0

[node name="Parts of a float" type="Label" parent="TabContainer"]
visible = false
custom_minimum_size = Vector2(1000, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("1_ybke6")
theme_override_styles/normal = SubResource("StyleBoxEmpty_bdfw8")
text = "    In order to understand how a float is represented in bits, we need to look at the different parts separately. Think about how we usually deal with scientific notation:

          5.14 x 10^4     =  51400
          1.29 x 10^(-7)  =  0.000000129
         -3.23 x 10^2     = -323

In binary, we can do very similar:

          1.101 x 2^4     = 11010
          1.01 x 2^(-5)   = 0.0000101
          1.111 x 2^2     = 111.1

It may help to separate this into 3 separate questions. Is the overall number negative? What is the number on the left side of the notation? What is the exponent that we take the base to?

We implement floats by making 3 sections of bits that each answer one of those questions.

Bit 1 determines whether the float is positive or negative
Bits 2-9 determine the exponent that 2 is taken to
Bits 10-32 determine the \"mantissa\", or rather the numbers to on to the left of the base in the scienfitic notation.

"
autowrap_mode = 2
metadata/_tab_index = 1

[node name="Common Pitfalls" type="Label" parent="TabContainer"]
visible = false
custom_minimum_size = Vector2(1100, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("1_ybke6")
theme_override_styles/normal = SubResource("StyleBoxEmpty_pr0yy")
text = "
There are two somewhat non-obvious rules that need to be paid attention to.

For the exponent, in order to reach negative exponents, we need something that isn't just interpreting those 8 bits as a raw int. We do this by subtracting 127 from result of the 8 bits. For example:

    00000001 = 2^(1-127) = 2^(-126)
    10000000 = 2^(128-127) = 2^1
    11001011 = 2^(203-127) = 2^6

Effectively, we can reach an approximation of any number between 2^(256-127) and 2^(1-127).  When the exponent bits are all equal to 0, we enter a region of this called \"Denormalized\" floats. We can expand on this more later, but this app does not currently teach this concept. If you do happen to be unlucky enough to be asked about a float with all 0's in the exponent region, go ahead and hit back in order to return and try again.

For the mantissa, there is always an implied 1 before the shown bits. If the mantissa is 0101110, then the actual number on the left of the scientific notation will be 1.0101110."
autowrap_mode = 2
metadata/_tab_index = 2

[node name="Example problem 1" type="Label" parent="TabContainer"]
visible = false
custom_minimum_size = Vector2(1000, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("1_ybke6")
theme_override_styles/normal = SubResource("StyleBoxEmpty_7b7cj")
text = "
Say we have the following 32 bits:

        0100 0010 0010 1000 1000 0000 0000 0000

We segment it off like this:

        0 10000100 01010001000000000000000

The first bit is 0, so the number will be positive.
The next 8 bits are equal to 132. We subtract 127 from that and we get 5, so our current equation is something x 2^5
We place a leading 1 in front of the remaining bits and we have:

        1.01010001 x 2^5 = 101010.001
        101010 in binary is 42 in base 10
        0.001 in binary is 1/8 so 0.125 in base 10
        So our answer is 42.125"
autowrap_mode = 2
metadata/_tab_index = 3

[node name="Example problem 2" type="Label" parent="TabContainer"]
visible = false
custom_minimum_size = Vector2(1000, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("1_ybke6")
theme_override_styles/normal = SubResource("StyleBoxEmpty_nv0k5")
text = "Say we have 13.65625

In binary, 13 is 1101. In order to find 0.65625 in binary, we just add smaller and smaller powers of 2 until we reach it:

        2^(-1) = 1/2,  0.65625 > 0.5, so we currently have 0.1
        2^(-2) = 1/4,  0.15625 < 0.25, so we keep going.
        2^(-3) = 1/8,  0.15625 > 0.125, so we have 0.101
        2^(-4) = 1/16, 0.03125 < 0.0625, so keep going
        2^(-5) = 1/32. 0.03125 = 0.03125, so we have 0.10101, done!

Our full binary number is 1101.10101

To translate this into a float, let's answer our 3 questions:

Is it positive? Yes, so the first bit will be 0.

What is the exponent? To get the decimal point behind the leading 1, we need to move 3 times, so our exponent should equal 3. 127 + 3 = 130. Our next 8 bits will therefore be 10000010

Our mantissa is the easy part now that this is all done. Drop the leading 1 and the mantissa is the remaining bits: 10110101 followed by enough 0's to hit 32 bits.

Finally, the answer is: 010000001010110101000000000000000000000"
autowrap_mode = 2
metadata/_tab_index = 4

[node name="BackToMain" parent="." instance=ExtResource("1_06n3i")]
layout_mode = 2
size_flags_horizontal = 8

[node name="MenuButtonName" parent="BackToMain" index="1"]
text = "Back"

[editable path="BackToMain"]
